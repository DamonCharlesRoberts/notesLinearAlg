{
  "hash": "5fea1c195653441ac77ce2ca1ecabdf2",
  "result": {
    "engine": "jupyter",
    "markdown": "# Matrices, Part I\n\n::: {#setup .cell execution_count=1}\n``` {.julia .cell-code}\n# Load packages\nusing LinearAlgebra\nusing Distributions\nusing Random\n```\n:::\n\n\n## Matrices\n\n::: {.callout-note title=\"Defintions\"}\n- Matrices:\n\t- Highly versitile mathematical objects.\n\t- In DS, they are often conceptualized as a horizontally stacked set of column vectors.\n\t\t- Often appear in the observations-by-feature format.\n\t\t\t- Rows are observations.\n\t\t\t- Columns are features (variables).\n\t\t- Indices are often denoted as Row $\\times$ Column.\n\t- Denoted with bold-faced capital letters.\n\t\t- E.g., **A** or **M**\n:::\n\n- Example of matrices:\n\n::: {#1dd3aff7 .cell execution_count=2}\n``` {.julia .cell-code}\n# Define a 3x5 matrix.\nA = [[1,0,1] [3,2,4] [5,4,7] [7,6,8] [9,8,9]]\nprintln(\"A, a 3x5 Matrix:$A\")\n\n# Ensure that it is 3x5\nnum_rows = size(A, 1)\nnum_columns = size(A, 2)\nprintln(\"A has $num_rows rows.\")\nprintln(\"A has $num_columns columns.\")\n# Slicing\n#     - Slice the first row.\nfirst_row = A[1, :]\nprintln(\"A's first row is: $first_row\")\n#     - Slice the first column.\nfirst_column = A[:, 1]\nprintln(\"A's first column is: $first_column\")\n#    - Slice the last row.\n#\t\t\t- Note that there are shortcuts.\nlast_row = A[end, :]\nprintln(\"A's last row is: $last_row\")\n#\t\t\t- Slice the last column.\n#\t\t\t\t- Note the shortcut.\nlast_column = A[:, end]\nprintln(\"A's last column is: $last_column\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA, a 3x5 Matrix:[1 3 5 7 9; 0 2 4 6 8; 1 4 7 8 9]\nA has 3 rows.\nA has 5 columns.\nA's first row is: [1, 3, 5, 7, 9]\nA's first column is: [1, 0, 1]\nA's last row is: [1, 4, 7, 8, 9]\nA's last column is: [9, 8, 9]\n```\n:::\n:::\n\n\n## Types of matrices\n- There are an infinite number of matrices. However, there are certain classes that are relatively common.\n\n### Random numbers matrix\n- Contains numbers drawn at random from some distribution.\n\n- Example:\n\n::: {#cell-random-matrix .cell execution_count=3}\n``` {.julia .cell-code}\n# There are many packages available.\n\n# Create a 3x3 matrix randomly generated from Gaussian dist.\n#\t\t- Create a Gaussian distribution with mean = 5 and std. dev = 2.\nmu = 5\nsigma_squared = 2\ndist = Distributions.Normal(mu, sigma_squared)\n# \t- Generate the matrix pulling from the dist.\nnum_rows = 3\nnum_features = 4\nmatrix = Random.rand(dist, num_rows, num_features)\nmatrix\n```\n\n::: {#random-matrix .cell-output .cell-output-display execution_count=4}\n```\n3×4 Matrix{Float64}:\n 6.3592   3.61815  2.68209  3.80779\n 7.73537  5.25992  5.50092  3.50644\n 4.8147   5.20514  3.63537  5.56604\n```\n:::\n:::\n\n\n### Square and rectangular matrices\n\n- The **Square matrix** is $\\mathbb{R}^{N \\times N}$\n\t- The matrix has the same number of rows as columns.\n- The **Rectangular matrix** is $\\mathbb{R}^{M \\times N}$ or $\\mathbb{R}^{N \\times M}$ where $M > N$.\n\t- **Tall** rectangular matrices are the former ($M \\times N$)\n\t- **Wide** rectangular matrices are the latter ($N \\times M$)\n\n- Example of square and rectangular matrices.\n\n::: {#cell-square-matrix .cell execution_count=4}\n``` {.julia .cell-code}\n# Define a Square matrix.\nsquare_matrix = Random.rand(3,3)\nprintln(\"Example of a Square Matrix:\")\nsquare_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExample of a Square Matrix:\n```\n:::\n\n::: {#square-matrix .cell-output .cell-output-display execution_count=5}\n```\n3×3 Matrix{Float64}:\n 0.570851  0.798623  0.240766\n 0.933675  0.832721  0.310331\n 0.586793  0.160646  0.523838\n```\n:::\n:::\n\n\n::: {#cell-tall-matrix .cell execution_count=5}\n``` {.julia .cell-code}\n# Define a Tall matrix.\ntall_matrix = Random.rand(4,3)\nprintln(\"Example of a Tall Matrix:\")\ntall_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExample of a Tall Matrix:\n```\n:::\n\n::: {#tall-matrix .cell-output .cell-output-display execution_count=6}\n```\n4×3 Matrix{Float64}:\n 0.720362  0.33162   0.325086\n 0.68186   0.296971  0.515731\n 0.514356  0.415962  0.0568227\n 0.982175  0.747093  0.265896\n```\n:::\n:::\n\n\n::: {#cell-wide-matrix .cell execution_count=6}\n``` {.julia .cell-code}\n# Define a Wide matrix.\nwide_matrix = Random.rand(3, 4)\nprintln(\"Example of a Wide Matrix:\")\nwide_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExample of a Wide Matrix:\n```\n:::\n\n::: {#wide-matrix .cell-output .cell-output-display execution_count=7}\n```\n3×4 Matrix{Float64}:\n 0.633416  0.508978  0.238866  0.6797\n 0.882501  0.62274   0.82069   0.925353\n 0.442554  0.829215  0.396217  0.302257\n```\n:::\n:::\n\n\n### Diagonal matrix\n\n- A square matrix that has zeros on all of the off-diagonal elements.\n\n- Example\n\n::: {#cell-diagonal-matrix .cell execution_count=7}\n``` {.julia .cell-code}\n# Create a diagonal matrix.\n#\t\t- Define the elements on the diagonal.\ndiag_ele = [1, 2, 3, 4]\n#\t\t- Create the matrix.\nD = LinearAlgebra.Diagonal(diag_ele)\nprintln(\"Example of a Diagonal Matrix:\")\nD\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExample of a Diagonal Matrix:\n```\n:::\n\n::: {#diagonal-matrix .cell-output .cell-output-display execution_count=8}\n```\n4×4 Diagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅  ⋅\n ⋅  2  ⋅  ⋅\n ⋅  ⋅  3  ⋅\n ⋅  ⋅  ⋅  4\n```\n:::\n:::\n\n\n### Identity Matrix\n\n- A special type of a square diagonal matrix where the elements on the diagonal are 1's.\n- Usually denoted as **I**.\n\n- Example\n\n::: {#cell-identity-matrix .cell execution_count=8}\n``` {.julia .cell-code}\n# Create a identity matrix.\n#\t\t- Define the size of the matrix.\nn = 4\n# \t- Create the matrix.\nI = LinearAlgebra.I(n)\nprintln(\"Example of a Identity Matrix:\")\nI\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExample of a Identity Matrix:\n```\n:::\n\n::: {#identity-matrix .cell-output .cell-output-display execution_count=9}\n```\n4×4 Diagonal{Bool, Vector{Bool}}:\n 1  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅\n ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  1\n```\n:::\n:::\n\n\n### Triangular Matrix\n- A matrix contains all zeros either above (**Upper Triangular**) or below (**Lower Triangular**) the diagonal.\n\n::: {#cell-triangular-matrices .cell execution_count=9}\n``` {.julia .cell-code}\n# Create a diagonal matrix.\ndiag_ele = [1, 2, 3, 4]\nD = LinearAlgebra.Diagonal(diag_ele)\nprintln(\"Diagonal Matrix:\")\nD\n#\tThe Upper Triangle.\nUT = LinearAlgebra.triu(D)\nprintln(\"Example of an Upper Triangle Matrix:\")\nUT\n# The Lower Triangle.\nLT = LinearAlgebra.tril(D)\nprintln(\"Example of a Lower Triangle Matrix:\")\nLT\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDiagonal Matrix:\nExample of an Upper Triangle Matrix:\nExample of a Lower Triangle Matrix:\n```\n:::\n\n::: {#triangular-matrices .cell-output .cell-output-display execution_count=10}\n```\n4×4 Diagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅  ⋅\n ⋅  2  ⋅  ⋅\n ⋅  ⋅  3  ⋅\n ⋅  ⋅  ⋅  4\n```\n:::\n:::\n\n\n### Zeros matrix\n- It is a Matrix of all Zeros.\n- Usually denoted as **0**.\n\n::: {#cell-zeros-matrix .cell execution_count=10}\n``` {.julia .cell-code}\n# Create a 4x4 Zeros matrix.\nO = LinearAlgebra.zeros(4,4)\nprintln(\"Example of a 4x4 Zero's Matrix:\")\nO\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExample of a 4x4 Zero's Matrix:\n```\n:::\n\n::: {#zeros-matrix .cell-output .cell-output-display execution_count=11}\n```\n4×4 Matrix{Float64}:\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n```\n:::\n:::\n\n\n## Matrix Addition\n\n- To add two matrices, you add their corresponding elements. That is:\n\n$$\nA+B = \\begin{bmatrix}(A11 + B11) & (A21 + B21)\\\\ (A12 + B12) & (A22 + B22)\\\\\\end{bmatrix}\n$$\n\n- As usual, they must be of the same size.\n- Example\n\n::: {#cell-adding-matrices .cell execution_count=11}\n``` {.julia .cell-code}\n# Defining the matrices.\nA = [[1, 2] [3, 4]]\nB = [[5, 6] [7, 8]]\nprintln(\"Matrix A:\")\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMatrix A:\n```\n:::\n\n::: {#adding-matrices .cell-output .cell-output-display execution_count=12}\n```\n2×2 Matrix{Int64}:\n 1  3\n 2  4\n```\n:::\n:::\n\n\n::: {#cell-adding-matrices-b .cell execution_count=12}\n``` {.julia .cell-code}\nprintln(\"Matrix B:\")\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMatrix B:\n```\n:::\n\n::: {#adding-matrices-b .cell-output .cell-output-display execution_count=13}\n```\n2×2 Matrix{Int64}:\n 5  7\n 6  8\n```\n:::\n:::\n\n\n::: {#cell-adding-matrices-result .cell execution_count=13}\n``` {.julia .cell-code}\n# Add the matrices\nC = A + B\nprintln(\"Result of adding the two matrices:\")\nC\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResult of adding the two matrices:\n```\n:::\n\n::: {#adding-matrices-result .cell-output .cell-output-display execution_count=14}\n```\n2×2 Matrix{Int64}:\n 6  10\n 8  12\n```\n:::\n:::\n\n\n## \"Shifting\" a matrix\n\n- You cannot formally add a scalar to a matrix as in $\\lambda + A$\n- You can broadcast a scalar to a square matrix. This is what is referred to as \"Shifting\" a matrix.\n\t- To do this, you take the scalar and multiply it to an identity matrix and then add the identity matrix to the resulting matrix.\n$$\nA + \\lambda I\n$$\n\n- Only the diagonal elements change. You don't want to shift much of the matrix. How much you shift a matrix depends a lot and is somewhat relative.\n- Shifting has two really important applications: finding eigenvalues of a matrix and regularizing matrices when fitting models to data.\n\n- Here's a numerical example\n\n$$\n\\begin{bmatrix}4 & 5 & 1\\\\ 0 & 1 & 11 \\\\ 4 & 9 & 7\\\\\\end{bmatrix} + 6 \\begin{bmatrix}1 & 0 & 0\\\\ 0 & 1 & 0\\\\ 0 & 0 & 1\\\\\\end{bmatrix} = \\begin{bmatrix}10 & 5 & 1\\\\ 0 & 7 & 11\\\\ 4 & 9 & 13\\\\\\end{bmatrix}\n$$\n\n- Here's how to do it in Julia.\n\n::: {#cell-matrix-shifting .cell execution_count=14}\n``` {.julia .cell-code}\n# Define the matrix.\nA = [[1, 2, 3] [4, 5, 6] [7, 8, 9]]\nprintln(\"Matrix A:\")\nA\n# Define the scalar.\nlambda = 2\n\n# Shift A.\nB = A + (lambda * LinearAlgebra.I(size(A, 1)))\nprintln(\"Shifted version of A + 2I\")\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMatrix A:\nShifted version of A + 2I\n```\n:::\n\n::: {#matrix-shifting .cell-output .cell-output-display execution_count=15}\n```\n3×3 Matrix{Int64}:\n 3  4   7\n 2  7   8\n 3  6  11\n```\n:::\n:::\n\n\n## Scalar and Hadamard multiplications\n\n- Both types of multiplication work element-wise.\n- Hadamard multiplication is identified with $A \\odot B$.\n\n- Example of scalar multiplication:\n\n::: {#cell-scalar-multiplication .cell execution_count=15}\n``` {.julia .cell-code}\n# Define the matrix.\nA = [[1,2] [1,2]]\nprintln(\"A:$A\")\n# Define the scalar.\nlambda = 2\n# Print the result of the scalar-multiplied A.\nlambda * A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA:[1 1; 2 2]\n```\n:::\n\n::: {#scalar-multiplication .cell-output .cell-output-display execution_count=16}\n```\n2×2 Matrix{Int64}:\n 2  2\n 4  4\n```\n:::\n:::\n\n\n- Example of Hadamard multiplication:\n\n::: {#cell-hadamard-multiplication .cell execution_count=16}\n``` {.julia .cell-code}\n# Define the two matrices.\nA = [[1, 1] [1, 1]]\nB = [[1, 2] [1, 2]]\n# Multiply the matrices.\n#   - Use the .* to do element-wise multiplication.\nA .* B\n```\n\n::: {#hadamard-multiplication .cell-output .cell-output-display execution_count=17}\n```\n2×2 Matrix{Int64}:\n 1  1\n 2  2\n```\n:::\n:::\n\n\n## Matrix multiplication\n\n- Recall the dot product between two vectors:\n\n$$\na^Tb = \\sum^n_{i=1}a_ib_i\n$$\n\n- Matrix multiplication is essentially the collection of dot products between rows of one matrix and columns of the other matrix.\n    - Specifically, the $(i,j)$th element in the product matrix is the dot product between the $i$th row of the left matrix and the $j$th column in the right matrix.\n- Conditions:\n    - If $A$ is $\\mathbb{R}^{M \\times N}$ then $B$ must be $\\mathbb{R}^{N \\times K}$.\n        - In words, the inner dimensions must mactch\n    - The result produces the outer dimensions, $AB$ is $\\mathbb{R}^{M \\times K}$.\n    - Does not obey the commutative law. So $AB$ may be valid but $BA$ will not be valid as $K \\neq M$.\n- Interpreting it: The product matrix is one that stores all of the pairwise linear relationships between the rows of the left matrix and the columns of the right matrix. This is the basis for computing covariance and correlation matrices, GLM, and many other applications.\n- Numerical example\n\n$$\n\\begin{bmatrix}2&3\\\\4&5\\\\\\end{bmatrix}\\begin{bmatrix}a&b\\\\c&d\\\\\\end{bmatrix} = \\begin{bmatrix}(2a + 3c) & (2b + 3d)\\\\(4a + 5c) & (4b + 5d)\\\\\\end{bmatrix}\n$$\n\n- Example in julia\n\n::: {#cell-matrix-multiplication .cell execution_count=17}\n``` {.julia .cell-code}\n# Define the matrices.\nA = [[2,4] [3,5]]\nB = [[2,4] [3,5]]\nprintln(\"A:$A\")\nprintln(\"B:$B\")\n# Multiply the matrices.\nA*B\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA:[2 3; 4 5]\nB:[2 3; 4 5]\n```\n:::\n\n::: {#matrix-multiplication .cell-output .cell-output-display execution_count=18}\n```\n2×2 Matrix{Int64}:\n 16  21\n 28  37\n```\n:::\n:::\n\n\n## Matrix-vector multiplication\n\n- Essentially matrix multiplication where one matrix happens to be a vector.\n- Extending the rules from matrix multiplication:\n    - A matrix can be right-multiplied by a column vector but not a row vector. $Av$ and $v^TA$ are valid but $Av^T$ and $vA$ are not valid.\n    - The product is always a vector and the orientation of the vector depends on the orientation of the multiplicand vector: premultiplying a row vector produces a row vector and postmultiplying a matrix by a column vector produces a column vector.\n- This is often used when obtaining the model-predicted values by multiplying the design matrix by the regression coefficients, $X\\beta$.\n\n## Linear weighted combinations\n- In the previous chapter we calculated these with separate scalars and vectors. Now we can do this in a more compact and scalable method: put the vectors in a matrix, put the weights into corresponding elements of a vector, then multiply.\n\n- Numerical example:\n\n$$\n4 \\begin{bmatrix}3\\\\0\\\\6\\\\\\end{bmatrix} + 3 \\begin{bmatrix}1\\\\2\\\\5\\\\\\end{bmatrix} \\implies \\begin{bmatrix}3&1\\\\0&2\\\\6&5\\\\\\end{bmatrix}\\begin{bmatrix}4\\\\3\\end{bmatrix}\\\\\n= \\begin{bmatrix}(12 + 3)\\\\(0 + 6)\\\\ (24 + 15)\\\\\\end{bmatrix}\n$$\n\n- Numerical example in Julia:\n\n::: {#linear-weighted .cell execution_count=18}\n``` {.julia .cell-code}\n# Define the matrices.\nA = [[3,0,6] [1,2,5]]\nb = [4,3]\n# Multiply them.\nprintln(\"A*b: \", A*b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA*b: [15, 6, 39]\n```\n:::\n:::\n\n\n## Transposing matrices\n\n- You swap the row and column indices.\n- Denoted with $A^T$.\n- Numerical example\n$$\n\\begin{bmatrix}\n    3&0&4\\\\\n    9&8&3\\\\\n\\end{bmatrix}^T\n= \\begin{bmatrix}\n    3&9\\\\\n    0&8\\\\\n    4&3\\\\\n\\end{bmatrix}\n$$\n- Example in Julia\n\n::: {#cell-transpose .cell execution_count=19}\n``` {.julia .cell-code}\n# Define the matrix\nA = [[3,9] [0,8] [4,3]]\n# Transpose the matrix\nA'\n```\n\n::: {#transpose .cell-output .cell-output-display execution_count=20}\n```\n3×2 adjoint(::Matrix{Int64}) with eltype Int64:\n 3  9\n 0  8\n 4  3\n```\n:::\n:::\n\n\n- For two column vectors of $M\\times 1$, transposing the vector and not the second gives a $1 \\times M$ matrix and a $M \\times 1$ matrix. The inner dimensions match and the product is $1 \\times 1$. This is why the dot product is denoted with $a^Tb$.\n\n## Order of operations: LIVE EVIL\n\n- The transose of multiplied matrices is the same as the individual matrices transposed and multiplied in rversed order.\n$$\n(LIVE)^T = E^TV^TI^TL^T\n$$\n\n## Symmetric matrices\n- The corresponding rows and columns are equal. This means that when you swap rows and columns, nothing changes.\n    - $A^T = A$\n- Needs to be a square matrix.\n- To create a symmetric matrix, you need to multipy any matrix (including nonsquare and nonsymmetric) by its transpose will produce a square symmetric matrix.\n    - $A^TA$ and $AA^T$ are both square symmetric.\n- The proof:\n    - If $A$ is $\\mathbb{R}^{M \\times N}$, then $A^T$ is $\\mathbb{R}^{N \\times M}$. $A^TA$ must then be $\\mathbb{R}^{N \\times N}$.\n\n",
    "supporting": [
      "ch_5_files"
    ],
    "filters": [],
    "includes": {}
  }
}